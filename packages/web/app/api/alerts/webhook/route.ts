import { NextRequest, NextResponse } from 'next/server'
import { headers } from 'next/headers'
import logger from '@/lib/logging'

interface AlertWebhookPayload {
  version: string
  groupKey: string
  status: 'firing' | 'resolved'
  receiver: string
  groupLabels: Record<string, string>
  commonLabels: Record<string, string>
  commonAnnotations: Record<string, string>
  externalURL: string
  alerts: Array<{
    status: 'firing' | 'resolved'
    labels: Record<string, string>
    annotations: Record<string, string>
    startsAt: string
    endsAt?: string
    generatorURL: string
    fingerprint: string
  }>
}

// Send notification to Slack
async function sendSlackNotification(
  payload: AlertWebhookPayload,
): Promise<void> {
  const slackWebhookUrl = process.env.SLACK_WEBHOOK_URL
  if (!slackWebhookUrl) return

  const color = payload.status === 'firing' ? 'danger' : 'good'
  const emoji = payload.status === 'firing' ? 'ðŸš¨' : 'âœ…'

  const fields = payload.alerts.map((alert) => {
    const severity = alert.labels.severity || 'unknown'
    const _service = alert.labels.service || 'unknown'

    return {
      title: `${severity.toUpperCase()}: ${alert.annotations.summary}`,
      value: alert.annotations.description,
      short: false,
    }
  })

  const slackPayload = {
    username: 'Notable Monitoring',
    icon_emoji: emoji,
    attachments: [
      {
        color,
        title: `${emoji} Alert ${payload.status.toUpperCase()}`,
        fields,
        footer: 'Notable Monitoring',
        ts: Math.floor(Date.now() / 1000),
      },
    ],
  }

  try {
    const response = await fetch(slackWebhookUrl, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify(slackPayload),
    })

    if (!response.ok) {
      throw new Error(`Slack API error: ${response.status}`)
    }

    logger.info('Slack notification sent', {
      status: payload.status,
      alertCount: payload.alerts.length,
    })
  } catch {
    logger.error('Failed to send Slack notification')
  }
}

// Send email notification
async function sendEmailNotification(
  payload: AlertWebhookPayload,
): Promise<void> {
  const resendApiKey = process.env.RESEND_API_KEY
  const emailFrom = process.env.EMAIL_FROM
  const alertEmail = process.env.ALERT_EMAIL || process.env.EMAIL_FROM

  if (!resendApiKey || !emailFrom || !alertEmail) return

  const subject = `[Notable] Alert ${payload.status.toUpperCase()}: ${payload.alerts.length} alert(s)`

  const alertList = payload.alerts
    .map(
      (alert) => `
    <div style="border-left: 4px solid ${payload.status === 'firing' ? '#ff4444' : '#44ff44'}; padding-left: 12px; margin: 12px 0;">
      <h3>${alert.annotations.summary}</h3>
      <p><strong>Severity:</strong> ${alert.labels.severity || 'unknown'}</p>
      <p><strong>Service:</strong> ${alert.labels.service || 'unknown'}</p>
      <p><strong>Description:</strong> ${alert.annotations.description}</p>
      <p><strong>Started:</strong> ${new Date(alert.startsAt).toLocaleString()}</p>
      ${alert.endsAt ? `<p><strong>Ended:</strong> ${new Date(alert.endsAt).toLocaleString()}</p>` : ''}
    </div>
  `,
    )
    .join('')

  const htmlContent = `
    <html>
      <body>
        <h1>Notable Monitoring Alert</h1>
        <p><strong>Status:</strong> ${payload.status.toUpperCase()}</p>
        <p><strong>Group:</strong> ${payload.groupLabels.alertname || 'Unknown'}</p>
        <p><strong>Time:</strong> ${new Date().toLocaleString()}</p>
        
        <h2>Alerts (${payload.alerts.length})</h2>
        ${alertList}
        
        <hr>
        <p><small>This alert was generated by Notable monitoring system.</small></p>
      </body>
    </html>
  `

  try {
    const response = await fetch('https://api.resend.com/emails', {
      method: 'POST',
      headers: {
        Authorization: `Bearer ${resendApiKey}`,
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        from: emailFrom,
        to: [alertEmail],
        subject,
        html: htmlContent,
      }),
    })

    if (!response.ok) {
      throw new Error(`Resend API error: ${response.status}`)
    }

    logger.info('Email notification sent', {
      status: payload.status,
      alertCount: payload.alerts.length,
    })
  } catch {
    logger.error('Failed to send email notification')
  }
}

// Store alert in database for incident tracking
async function storeAlert(payload: AlertWebhookPayload): Promise<void> {
  try {
    const { createClient } = await import('@supabase/supabase-js')
    const supabase = createClient(
      process.env.NEXT_PUBLIC_SUPABASE_URL!,
      process.env.SUPABASE_SERVICE_ROLE_KEY!,
    )

    for (const alert of payload.alerts) {
      const { error } = await supabase.from('monitoring_alerts').insert({
        fingerprint: alert.fingerprint,
        status: alert.status,
        severity: alert.labels.severity || 'unknown',
        service: alert.labels.service || 'unknown',
        alert_name: alert.labels.alertname || 'Unknown',
        summary: alert.annotations.summary,
        description: alert.annotations.description,
        labels: alert.labels,
        annotations: alert.annotations,
        starts_at: alert.startsAt,
        ends_at: alert.endsAt,
        generator_url: alert.generatorURL,
      })

      if (error) {
        logger.error('Failed to store alert in database', { error, alert })
      }
    }
  } catch {
    logger.error('Failed to store alerts')
  }
}

// Main webhook handler
export async function POST(_request: NextRequest) {
  try {
    // Verify webhook signature if configured
    const _headersList = headers()
    const signature = _headersList.get('x-alertmanager-signature')
    const webhookSecret = process.env.ALERTMANAGER_WEBHOOK_SECRET

    if (webhookSecret && signature) {
      // Implement signature verification here
      // For production, verify the HMAC signature
    }

    const payload: AlertWebhookPayload = await _request.json()

    logger.info('Alert webhook received', {
      status: payload.status,
      alertCount: payload.alerts.length,
      groupKey: payload.groupKey,
    })

    // Process alerts in parallel
    await Promise.all([
      sendSlackNotification(payload),
      sendEmailNotification(payload),
      storeAlert(payload),
    ])

    return NextResponse.json({
      success: true,
      processed: payload.alerts.length,
    })
  } catch {
    logger.error('Alert webhook error')
    return NextResponse.json(
      { error: 'Internal server error' },
      { status: 500 },
    )
  }
}

// Health check for the webhook endpoint
export async function GET() {
  return NextResponse.json({
    status: 'healthy',
    timestamp: new Date().toISOString(),
  })
}
